x = 0:100;

a1 = 1;
a2 = sqrt(10);

%%%%%%
% h1 %
%%%%%%
x1 = rand(1, 101);

%convolving x1 with unit step
x1 = conv(x1, heaviside(x));

% Building yc and yi using separate gain application methods
yc1 = (a1*x1+a2*x1)+(a1*x1+a2*x1);
yi1 = (a1*(x1+x1))+(a2*(x1+x1));

% Rounding off values to prevent false negatives due to rounding
% inconsistency
yc1 = round(yc1, 2);
yi1 = round(yi1, 2);

% Checking equivalence
if isequal(yc1, yi1)
    disp('linear')
else 
    disp('not linear')
end

%%%%%%
% h2 %
%%%%%%
y2 = normrnd(0, 1, 1, 101);

% Building right-shifted vector for use in [n+1] part of function %%

% Concatenating y2 with a 1x1 vector containing 0, hence assuming that
% values <= 0 are 0 
shifted = [0, y2];

% Cutting off highest index to restore proper vector length
slice = temp(1:101);
final = n.*slice;

% Building yc and yi using separate gain application methods
yc2 = (a1*y2+a2*y2)+(a1*final+a2*final);
yi2 = (a1*(y2+final))+(a2*(y2+final));

% Rounding off values to prevent false negatives due to rounding
% inconsistency
yc2 = round(yc2, 2);
yi2 = round(yi2, 2);

% Checking equivalence
if isequal(yc2, yi2)
    disp('linear')
else 
    disp('not linear')
end